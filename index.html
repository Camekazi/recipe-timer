<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Recipe Timer Generator</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: #eee;
      min-height: 100vh;
      padding: 20px;
      padding-bottom: 100px;
    }

    h1 { text-align: center; font-size: 1.8em; margin-bottom: 10px; color: #ff6b35; }
    .subtitle { text-align: center; color: #888; margin-bottom: 30px; font-size: 0.9em; }

    /* Setup Section */
    #setup-section, #unlock-section { max-width: 500px; margin: 0 auto; }

    .input-group { margin-bottom: 20px; }
    .input-group label { display: block; margin-bottom: 8px; color: #ff6b35; font-weight: 600; }
    .input-group input, .input-group textarea {
      width: 100%;
      padding: 15px;
      border: 2px solid #333;
      border-radius: 12px;
      background: #252545;
      color: #eee;
      font-size: 1em;
    }
    .input-group textarea { min-height: 100px; resize: vertical; }
    .input-group input:focus, .input-group textarea:focus {
      outline: none;
      border-color: #ff6b35;
    }
    .input-group small { display: block; margin-top: 8px; color: #888; font-size: 0.85em; }
    .input-group small a { color: #ff6b35; }

    .info-box {
      background: rgba(99, 102, 241, 0.1);
      border: 1px solid #6366f1;
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 20px;
      font-size: 0.9em;
      color: #a5b4fc;
    }

    .btn-primary {
      width: 100%;
      background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%);
      color: white;
      border: none;
      padding: 18px;
      font-size: 1.2em;
      border-radius: 12px;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(255, 107, 53, 0.4);
    }
    .btn-primary:hover { transform: scale(1.02); }
    .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }

    /* Input Mode Tabs */
    .input-tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
    }
    .input-tab {
      flex: 1;
      padding: 12px;
      background: #252545;
      border: 2px solid #333;
      border-radius: 10px;
      color: #888;
      cursor: pointer;
      text-align: center;
      font-size: 0.95em;
    }
    .input-tab.active {
      border-color: #ff6b35;
      color: #ff6b35;
      background: rgba(255, 107, 53, 0.1);
    }

    /* Photo Input */
    .photo-input {
      display: none;
    }
    .photo-input.active { display: block; }
    .text-input.active { display: block; }
    .text-input { display: none; }

    .photo-buttons {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
    }
    .photo-btn {
      flex: 1;
      padding: 15px;
      background: #252545;
      border: 2px dashed #444;
      border-radius: 12px;
      color: #aaa;
      cursor: pointer;
      text-align: center;
    }
    .photo-btn:hover { border-color: #ff6b35; color: #ff6b35; }

    .photo-preview {
      display: none;
      margin-bottom: 15px;
    }
    .photo-preview img {
      max-width: 100%;
      border-radius: 12px;
      border: 2px solid #4ade80;
    }
    .photo-preview .remove-btn {
      display: block;
      margin-top: 10px;
      padding: 8px;
      background: #ef4444;
      border: none;
      border-radius: 8px;
      color: white;
      cursor: pointer;
      font-size: 0.9em;
    }

    .cached-recipes { margin-top: 30px; }
    .cached-recipes h3 { color: #888; font-size: 0.9em; margin-bottom: 10px; }
    .cached-item {
      background: #252545;
      padding: 12px 15px;
      border-radius: 8px;
      margin-bottom: 8px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .cached-item:hover { background: #2d2d5a; }
    .cached-item .title { font-weight: 600; }
    .cached-item .meta { color: #888; font-size: 0.85em; }

    /* Loading */
    #loading-section { display: none; text-align: center; padding: 60px 20px; }
    .spinner {
      width: 50px; height: 50px;
      border: 4px solid #333;
      border-top-color: #ff6b35;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 20px;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* Timer Section */
    #timer-section { display: none; }

    .elapsed-time {
      text-align: center;
      font-size: 2.5em;
      font-weight: bold;
      color: #ff6b35;
      margin-bottom: 20px;
      font-variant-numeric: tabular-nums;
    }

    .section-title {
      font-size: 0.85em;
      text-transform: uppercase;
      letter-spacing: 2px;
      color: #ff6b35;
      margin-bottom: 15px;
      padding-bottom: 5px;
      border-bottom: 1px solid #333;
    }

    .current-step {
      background: linear-gradient(135deg, #2d4a3e 0%, #1e3a2f 100%);
      border: 2px solid #4ade80;
      border-radius: 15px;
      padding: 25px;
      margin-bottom: 30px;
      box-shadow: 0 0 20px rgba(74, 222, 128, 0.2);
    }
    .current-step h2 { font-size: 1.4em; margin-bottom: 10px; color: #4ade80; }
    .current-step p { color: #ccc; line-height: 1.6; }
    .current-step .duration { margin-top: 15px; font-size: 1.1em; color: #4ade80; }

    .upcoming-step {
      background: #252545;
      border-radius: 12px;
      padding: 15px 20px;
      margin-bottom: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-left: 4px solid #ff6b35;
    }
    .upcoming-step.soon { border-left-color: #fbbf24; animation: pulse 2s infinite; }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
    .upcoming-step .title { font-weight: 600; margin-bottom: 3px; }
    .upcoming-step .detail { font-size: 0.85em; color: #888; }
    .upcoming-step .countdown {
      font-size: 1.2em;
      font-weight: bold;
      color: #ff6b35;
      font-variant-numeric: tabular-nums;
      min-width: 60px;
      text-align: right;
    }

    .timeline-step {
      display: flex;
      padding: 12px 0;
      border-bottom: 1px solid #333;
    }
    .timeline-step.completed { opacity: 0.5; }
    .timeline-step.completed .timeline-title { text-decoration: line-through; }
    .timeline-step.active {
      background: rgba(74, 222, 128, 0.1);
      margin: 0 -20px;
      padding: 12px 20px;
      border-radius: 8px;
    }
    .timeline-time { min-width: 70px; font-size: 0.85em; color: #888; }
    .timeline-content { flex: 1; }
    .timeline-title { font-weight: 600; margin-bottom: 3px; }
    .timeline-detail { font-size: 0.85em; color: #888; }

    .done-section { display: none; text-align: center; padding: 60px 20px; }
    .done-section h2 { font-size: 2em; margin-bottom: 20px; }

    .paused-banner {
      display: none;
      background: #fbbf24;
      color: #000;
      text-align: center;
      padding: 10px;
      font-weight: bold;
      margin-bottom: 20px;
      border-radius: 8px;
    }

    .controls {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: #1a1a2e;
      padding: 15px 20px;
      display: none;
      gap: 10px;
      border-top: 1px solid #333;
    }
    .controls button {
      flex: 1;
      padding: 12px;
      border: none;
      border-radius: 8px;
      font-size: 1em;
      cursor: pointer;
    }
    #pause-btn { background: #fbbf24; color: #000; }
    #reset-btn { background: #ef4444; color: white; }
    #new-btn { background: #6366f1; color: white; }

    .error-msg { color: #ef4444; text-align: center; margin-top: 20px; }

    .key-actions {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }
    .key-actions button {
      flex: 1;
      padding: 8px;
      border: 1px solid #444;
      border-radius: 6px;
      background: transparent;
      color: #888;
      cursor: pointer;
      font-size: 0.85em;
    }
    .key-actions button:hover { border-color: #ff6b35; color: #ff6b35; }

    #unlock-section { display: none; }
  </style>
</head>
<body>
  <h1>Recipe Timer</h1>
  <p class="subtitle">AI-powered cooking timers</p>

  <!-- Unlock Section (for encrypted keys) -->
  <div id="unlock-section">
    <div class="input-group">
      <label>Enter your passphrase</label>
      <input type="password" id="unlock-passphrase" placeholder="Your passphrase to unlock the API key">
    </div>
    <button class="btn-primary" onclick="unlockKey()">Unlock</button>
    <div class="key-actions">
      <button onclick="forgetKey()">Use Different Key</button>
    </div>
    <div id="unlock-error" class="error-msg"></div>
  </div>

  <!-- Setup Section -->
  <div id="setup-section">
    <div class="input-group">
      <label>Gemini API Key</label>
      <input type="password" id="api-key" placeholder="Enter your Gemini API key">
      <small>
        Get a free key at <a href="https://aistudio.google.com/apikey" target="_blank">Google AI Studio</a> (250/day free)
      </small>
    </div>

    <div class="input-group">
      <label>Passphrase (optional)</label>
      <input type="password" id="passphrase" placeholder="Encrypt your key with a passphrase">
      <small>If set, your key is encrypted. Leave blank for plain storage.</small>
    </div>

    <div class="info-box">
      With a passphrase, your key is AES-256 encrypted. Without one, it's stored in plain text (visible in DevTools).
    </div>

    <!-- Input Mode Tabs -->
    <div class="input-tabs">
      <div class="input-tab active" onclick="setInputMode('text')">Type Recipe</div>
      <div class="input-tab" onclick="setInputMode('photo')">Photo</div>
    </div>

    <!-- Text Input -->
    <div id="text-input" class="text-input active">
      <div class="input-group">
        <label>What are you cooking?</label>
        <textarea id="recipe-input" placeholder="e.g., Chicken stir fry with vegetables&#10;&#10;Or paste a full recipe..."></textarea>
      </div>
    </div>

    <!-- Photo Input -->
    <div id="photo-input" class="photo-input">
      <div class="photo-buttons">
        <label class="photo-btn" for="camera-input">
          Take Photo
          <input type="file" id="camera-input" accept="image/*" capture="environment" style="display:none" onchange="handlePhoto(this)">
        </label>
        <label class="photo-btn" for="upload-input">
          Upload Image
          <input type="file" id="upload-input" accept="image/*" style="display:none" onchange="handlePhoto(this)">
        </label>
      </div>
      <div id="photo-preview" class="photo-preview">
        <img id="preview-img" src="">
        <button class="remove-btn" onclick="removePhoto()">Remove Photo</button>
      </div>
    </div>

    <button id="generate-btn" class="btn-primary" onclick="generateTimer()">Generate Timer</button>
    <div id="error-msg" class="error-msg"></div>

    <div id="cached-section" class="cached-recipes" style="display: none;">
      <h3>Recent Recipes</h3>
      <div id="cached-list"></div>
    </div>
  </div>

  <!-- Loading Section -->
  <div id="loading-section">
    <div class="spinner"></div>
    <p id="loading-text">Generating your cooking timer...</p>
  </div>

  <!-- Timer Section -->
  <div id="timer-section">
    <div class="paused-banner" id="paused-banner">PAUSED</div>
    <div class="elapsed-time" id="elapsed-time">00:00</div>

    <div class="section-title">Do This Now</div>
    <div class="current-step" id="current-step">
      <h2>Loading...</h2>
      <p></p>
    </div>

    <div class="upcoming-section">
      <div class="section-title">Coming Up Next</div>
      <div id="upcoming-steps"></div>
    </div>

    <div class="timeline-section" style="margin-top: 40px;">
      <div class="section-title">Full Timeline</div>
      <div id="timeline"></div>
    </div>
  </div>

  <!-- Done Section -->
  <div class="done-section" id="done-section">
    <h2>All Done!</h2>
    <p id="done-message">Your meal is ready to serve!</p>
  </div>

  <!-- Controls -->
  <div class="controls" id="controls">
    <button id="pause-btn" onclick="togglePause()">Pause</button>
    <button id="reset-btn" onclick="resetTimer()">Reset</button>
    <button id="new-btn" onclick="newRecipe()">New Recipe</button>
  </div>

  <script>
    // Safe localStorage wrapper (iOS Safari blocks on file:// URLs)
    const storage = {
      get: (key) => { try { return localStorage.getItem(key); } catch(e) { return null; } },
      set: (key, val) => { try { localStorage.setItem(key, val); } catch(e) {} },
      remove: (key) => { try { localStorage.removeItem(key); } catch(e) {} }
    };

    let steps = [];
    let recipeTitle = '';
    let startTime = null;
    let pausedTime = null;
    let isPaused = false;
    let intervalId = null;
    let currentInputMode = 'text';
    let selectedPhoto = null;
    let decryptedApiKey = null;

    // ==================== ENCRYPTION ====================
    async function deriveKey(passphrase, salt) {
      const enc = new TextEncoder();
      const keyMaterial = await crypto.subtle.importKey(
        'raw', enc.encode(passphrase), 'PBKDF2', false, ['deriveKey']
      );
      return crypto.subtle.deriveKey(
        { name: 'PBKDF2', salt, iterations: 100000, hash: 'SHA-256' },
        keyMaterial,
        { name: 'AES-GCM', length: 256 },
        false,
        ['encrypt', 'decrypt']
      );
    }

    async function encryptApiKey(apiKey, passphrase) {
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const key = await deriveKey(passphrase, salt);
      const encrypted = await crypto.subtle.encrypt(
        { name: 'AES-GCM', iv },
        key,
        new TextEncoder().encode(apiKey)
      );
      return {
        salt: Array.from(salt),
        iv: Array.from(iv),
        ciphertext: Array.from(new Uint8Array(encrypted))
      };
    }

    async function decryptApiKey(stored, passphrase) {
      const salt = new Uint8Array(stored.salt);
      const iv = new Uint8Array(stored.iv);
      const ciphertext = new Uint8Array(stored.ciphertext);
      const key = await deriveKey(passphrase, salt);
      const decrypted = await crypto.subtle.decrypt(
        { name: 'AES-GCM', iv },
        key,
        ciphertext
      );
      return new TextDecoder().decode(decrypted);
    }

    // ==================== INIT ====================
    window.onload = function() {
      // Check for encrypted key
      const encryptedKey = storage.get('geminiKeyEncrypted');
      const plainKey = storage.get('geminiApiKey');

      if (encryptedKey) {
        // Show unlock screen
        document.getElementById('setup-section').style.display = 'none';
        document.getElementById('unlock-section').style.display = 'block';
      } else if (plainKey) {
        document.getElementById('api-key').value = plainKey;
        decryptedApiKey = plainKey;
      }

      loadCachedRecipes();

      // Check for active timer session
      const activeRecipe = storage.get('activeRecipe');
      if (activeRecipe && decryptedApiKey) {
        const data = JSON.parse(activeRecipe);
        if (confirm(`Resume "${data.title}"?`)) {
          steps = data.steps;
          recipeTitle = data.title;
          startCooking();
        } else {
          storage.remove('activeRecipe');
          storage.remove('timerStartTime');
        }
      }
    };

    async function unlockKey() {
      const passphrase = document.getElementById('unlock-passphrase').value;
      const errorEl = document.getElementById('unlock-error');

      if (!passphrase) {
        errorEl.textContent = 'Please enter your passphrase';
        return;
      }

      try {
        const stored = JSON.parse(storage.get('geminiKeyEncrypted'));
        decryptedApiKey = await decryptApiKey(stored, passphrase);
        document.getElementById('unlock-section').style.display = 'none';
        document.getElementById('setup-section').style.display = 'block';
        document.getElementById('api-key').value = '••••••••••••••••';
        document.getElementById('api-key').disabled = true;

        // Check for active recipe after unlock
        const activeRecipe = storage.get('activeRecipe');
        if (activeRecipe) {
          const data = JSON.parse(activeRecipe);
          if (confirm(`Resume "${data.title}"?`)) {
            steps = data.steps;
            recipeTitle = data.title;
            startCooking();
          }
        }
      } catch (e) {
        errorEl.textContent = 'Wrong passphrase. Try again.';
      }
    }

    function forgetKey() {
      if (confirm('Remove saved API key? You\'ll need to enter it again.')) {
        storage.remove('geminiKeyEncrypted');
        storage.remove('geminiApiKey');
        decryptedApiKey = null;
        document.getElementById('unlock-section').style.display = 'none';
        document.getElementById('setup-section').style.display = 'block';
        document.getElementById('api-key').value = '';
        document.getElementById('api-key').disabled = false;
      }
    }

    // ==================== INPUT MODES ====================
    function setInputMode(mode) {
      currentInputMode = mode;
      document.querySelectorAll('.input-tab').forEach(t => t.classList.remove('active'));
      document.querySelector(`.input-tab:${mode === 'text' ? 'first' : 'last'}-child`).classList.add('active');

      document.getElementById('text-input').classList.toggle('active', mode === 'text');
      document.getElementById('photo-input').classList.toggle('active', mode === 'photo');
    }

    function handlePhoto(input) {
      if (input.files && input.files[0]) {
        const file = input.files[0];

        // Compress if too large (>4MB)
        if (file.size > 4 * 1024 * 1024) {
          compressImage(file).then(compressed => {
            selectedPhoto = compressed;
            showPhotoPreview(compressed);
          });
        } else {
          const reader = new FileReader();
          reader.onload = (e) => {
            selectedPhoto = e.target.result;
            showPhotoPreview(e.target.result);
          };
          reader.readAsDataURL(file);
        }
      }
    }

    function compressImage(file) {
      return new Promise((resolve) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const img = new Image();
        img.onload = () => {
          const maxSize = 1600;
          let w = img.width, h = img.height;
          if (w > h && w > maxSize) { h = h * maxSize / w; w = maxSize; }
          else if (h > maxSize) { w = w * maxSize / h; h = maxSize; }
          canvas.width = w;
          canvas.height = h;
          ctx.drawImage(img, 0, 0, w, h);
          resolve(canvas.toDataURL('image/jpeg', 0.8));
        };
        img.src = URL.createObjectURL(file);
      });
    }

    function showPhotoPreview(dataUrl) {
      document.getElementById('preview-img').src = dataUrl;
      document.getElementById('photo-preview').style.display = 'block';
    }

    function removePhoto() {
      selectedPhoto = null;
      document.getElementById('photo-preview').style.display = 'none';
      document.getElementById('camera-input').value = '';
      document.getElementById('upload-input').value = '';
    }

    // ==================== RECIPE GENERATION ====================
    function loadCachedRecipes() {
      const cached = storage.get('cachedRecipes');
      if (!cached) return;

      const recipes = JSON.parse(cached);
      if (recipes.length === 0) return;

      const list = document.getElementById('cached-list');
      list.innerHTML = recipes.slice(0, 5).map((r, i) => `
        <div class="cached-item" onclick="loadCached(${i})">
          <div>
            <div class="title">${r.title}</div>
            <div class="meta">${r.steps.length} steps</div>
          </div>
          <span>→</span>
        </div>
      `).join('');

      document.getElementById('cached-section').style.display = 'block';
    }

    function loadCached(index) {
      const cached = JSON.parse(storage.get('cachedRecipes'));
      const recipe = cached[index];
      steps = recipe.steps;
      recipeTitle = recipe.title;
      saveActiveRecipe();
      startCooking();
    }

    async function generateTimer() {
      const apiKeyInput = document.getElementById('api-key').value.trim();
      const passphrase = document.getElementById('passphrase').value;
      const recipeInput = document.getElementById('recipe-input').value.trim();
      const errorEl = document.getElementById('error-msg');

      // Get API key (either decrypted or from input)
      let apiKey = decryptedApiKey || apiKeyInput;

      if (!apiKey) { errorEl.textContent = 'Please enter your API key'; return; }
      if (currentInputMode === 'text' && !recipeInput) {
        errorEl.textContent = 'Please describe what you\'re cooking';
        return;
      }
      if (currentInputMode === 'photo' && !selectedPhoto) {
        errorEl.textContent = 'Please take or upload a photo';
        return;
      }

      errorEl.textContent = '';

      // Save API key (encrypted or plain)
      if (!decryptedApiKey) {
        if (passphrase) {
          const encrypted = await encryptApiKey(apiKey, passphrase);
          storage.set('geminiKeyEncrypted', JSON.stringify(encrypted));
          storage.remove('geminiApiKey');
        } else {
          storage.set('geminiApiKey', apiKey);
          storage.remove('geminiKeyEncrypted');
        }
        decryptedApiKey = apiKey;
      }

      // Show loading
      document.getElementById('setup-section').style.display = 'none';
      document.getElementById('loading-section').style.display = 'block';
      document.getElementById('loading-text').textContent =
        currentInputMode === 'photo' ? 'Reading recipe from photo...' : 'Generating your cooking timer...';

      try {
        // Build request based on input mode
        let parts = [];

        if (currentInputMode === 'photo') {
          // Extract base64 data from data URL
          const base64Data = selectedPhoto.split(',')[1];
          const mimeType = selectedPhoto.split(';')[0].split(':')[1];

          parts = [
            {
              inlineData: {
                mimeType: mimeType,
                data: base64Data
              }
            },
            {
              text: `Extract the recipe from this image and create a cooking timer. Return ONLY valid JSON, no markdown.

Return this exact JSON structure:
{
  "title": "Recipe Name",
  "totalMinutes": 30,
  "steps": [
    {"time": 0, "title": "Step name", "detail": "What to do", "duration": 300},
    {"time": 300, "title": "Next step", "detail": "Instructions", "duration": 180}
  ]
}

Rules:
- time = seconds from start when step begins
- duration = how long this step takes in seconds
- Each step's time should equal previous step's time + duration
- Include prep, cooking, and any resting time
- Be realistic about timing
- Keep details concise but helpful`
            }
          ];
        } else {
          parts = [{
            text: `Create a cooking timer for this recipe. Return ONLY valid JSON, no markdown.

Recipe: ${recipeInput}

Return this exact JSON structure:
{
  "title": "Recipe Name",
  "totalMinutes": 30,
  "steps": [
    {"time": 0, "title": "Step name", "detail": "What to do", "duration": 300},
    {"time": 300, "title": "Next step", "detail": "Instructions", "duration": 180}
  ]
}

Rules:
- time = seconds from start when step begins
- duration = how long this step takes in seconds
- Each step's time should equal previous step's time + duration
- Include prep, cooking, and any resting time
- Be realistic about timing
- Keep details concise but helpful`
          }];
        }

        const response = await fetch(
          `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`,
          {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              contents: [{ parts }],
              generationConfig: {
                temperature: 0.7,
                maxOutputTokens: 2048
              }
            })
          }
        );

        if (!response.ok) {
          const err = await response.json();
          throw new Error(err.error?.message || 'API request failed');
        }

        const data = await response.json();
        const text = data.candidates[0].content.parts[0].text;

        // Parse JSON (handle markdown code blocks)
        let jsonStr = text;
        if (text.includes('```')) {
          jsonStr = text.replace(/```json?\n?/g, '').replace(/```/g, '').trim();
        }

        const recipe = JSON.parse(jsonStr);
        steps = recipe.steps;
        recipeTitle = recipe.title;

        // Cache and start
        cacheRecipe(recipe);
        saveActiveRecipe();
        startCooking();

      } catch (err) {
        console.error(err);
        document.getElementById('loading-section').style.display = 'none';
        document.getElementById('setup-section').style.display = 'block';
        errorEl.textContent = `Error: ${err.message}`;
      }
    }

    function cacheRecipe(recipe) {
      let cached = JSON.parse(storage.get('cachedRecipes') || '[]');
      cached = cached.filter(r => r.title !== recipe.title);
      cached.unshift(recipe);
      cached = cached.slice(0, 10);
      storage.set('cachedRecipes', JSON.stringify(cached));
    }

    function saveActiveRecipe() {
      storage.set('activeRecipe', JSON.stringify({ title: recipeTitle, steps }));
    }

    // ==================== TIMER ====================
    function startCooking() {
      const saved = storage.get('timerStartTime');
      const savedPaused = storage.get('timerPausedTime');

      if (saved && !savedPaused) {
        startTime = parseInt(saved);
      } else if (saved && savedPaused) {
        const pauseDuration = Date.now() - parseInt(savedPaused);
        startTime = parseInt(saved) + pauseDuration;
        storage.set('timerStartTime', startTime);
        storage.remove('timerPausedTime');
      } else {
        startTime = Date.now();
        storage.set('timerStartTime', startTime);
      }

      document.getElementById('loading-section').style.display = 'none';
      document.getElementById('setup-section').style.display = 'none';
      document.getElementById('unlock-section').style.display = 'none';
      document.getElementById('timer-section').style.display = 'block';
      document.getElementById('controls').style.display = 'flex';

      document.querySelector('h1').textContent = recipeTitle;

      renderTimeline();
      updateDisplay();
      intervalId = setInterval(updateDisplay, 1000);
    }

    function togglePause() {
      isPaused = !isPaused;
      const btn = document.getElementById('pause-btn');
      const banner = document.getElementById('paused-banner');

      if (isPaused) {
        pausedTime = Date.now();
        storage.set('timerPausedTime', pausedTime);
        btn.textContent = 'Resume';
        banner.style.display = 'block';
        clearInterval(intervalId);
      } else {
        const pauseDuration = Date.now() - pausedTime;
        startTime += pauseDuration;
        storage.set('timerStartTime', startTime);
        storage.remove('timerPausedTime');
        pausedTime = null;
        btn.textContent = 'Pause';
        banner.style.display = 'none';
        intervalId = setInterval(updateDisplay, 1000);
      }
    }

    function resetTimer() {
      if (confirm('Reset the timer? This will start over.')) {
        storage.remove('timerStartTime');
        storage.remove('timerPausedTime');
        clearInterval(intervalId);
        startTime = Date.now();
        storage.set('timerStartTime', startTime);
        isPaused = false;
        document.getElementById('pause-btn').textContent = 'Pause';
        document.getElementById('paused-banner').style.display = 'none';
        document.getElementById('done-section').style.display = 'none';
        document.getElementById('timer-section').style.display = 'block';
        renderTimeline();
        updateDisplay();
        intervalId = setInterval(updateDisplay, 1000);
      }
    }

    function newRecipe() {
      storage.remove('timerStartTime');
      storage.remove('timerPausedTime');
      storage.remove('activeRecipe');
      clearInterval(intervalId);
      location.reload();
    }

    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = seconds % 60;
      return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }

    function formatClockTime(seconds) {
      const d = new Date(startTime + seconds * 1000);
      return d.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });
    }

    function getElapsedSeconds() {
      return Math.floor((Date.now() - startTime) / 1000);
    }

    function getCurrentStepIndex(elapsed) {
      for (let i = steps.length - 1; i >= 0; i--) {
        if (elapsed >= steps[i].time) return i;
      }
      return 0;
    }

    function updateDisplay() {
      const elapsed = getElapsedSeconds();
      const totalTime = steps[steps.length - 1].time + steps[steps.length - 1].duration;

      document.getElementById('elapsed-time').textContent = formatTime(elapsed);

      if (elapsed >= totalTime) {
        document.getElementById('timer-section').style.display = 'none';
        document.getElementById('done-section').style.display = 'block';
        document.getElementById('done-message').textContent = `${recipeTitle} is ready!`;
        storage.remove('activeRecipe');
        storage.remove('timerStartTime');
        clearInterval(intervalId);
        return;
      }

      const currentIndex = getCurrentStepIndex(elapsed);
      const current = steps[currentIndex];
      const timeInStep = elapsed - current.time;
      const remaining = current.duration - timeInStep;

      document.getElementById('current-step').innerHTML = `
        <h2>${current.title}</h2>
        <p>${current.detail}</p>
        ${remaining > 0 ? `<div class="duration">${formatTime(Math.max(0, remaining))} remaining</div>` : ''}
      `;

      const upcomingEl = document.getElementById('upcoming-steps');
      const upcoming = steps.slice(currentIndex + 1, currentIndex + 4);
      upcomingEl.innerHTML = upcoming.map(step => {
        const countdown = step.time - elapsed;
        return `
          <div class="upcoming-step ${countdown < 120 ? 'soon' : ''}">
            <div>
              <div class="title">${step.title}</div>
              <div class="detail">${step.detail.substring(0, 50)}${step.detail.length > 50 ? '...' : ''}</div>
            </div>
            <div class="countdown">${formatTime(countdown)}</div>
          </div>
        `;
      }).join('');

      document.querySelectorAll('.timeline-step').forEach((el, i) => {
        el.classList.remove('completed', 'active');
        if (i < currentIndex) el.classList.add('completed');
        if (i === currentIndex) el.classList.add('active');
      });
    }

    function renderTimeline() {
      document.getElementById('timeline').innerHTML = steps.map((step, i) => `
        <div class="timeline-step" data-index="${i}">
          <div class="timeline-time">${formatClockTime(step.time)}</div>
          <div class="timeline-content">
            <div class="timeline-title">${step.title}</div>
            <div class="timeline-detail">${step.detail}</div>
          </div>
        </div>
      `).join('');
    }
  </script>
</body>
</html>
